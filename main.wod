import "util";
import "math";
import "renderer";
import "rb";

inline void print_3x4(int[12] m) {
    print(f"{m[0]} {m[1]} {m[2]} {m[3]}");
    print(f"{m[4]} {m[5]} {m[6]} {m[7]}");
    print(f"{m[8]} {m[9]} {m[10]} {m[11]}");
}

inline void print_rb_transform() {
    print("");
    print(f"{RigidBodies[0].transform[0]} {RigidBodies[0].transform[1]} {RigidBodies[0].transform[2]} {RigidBodies[0].transform[3]}");        
    print(f"{RigidBodies[0].transform[4]} {RigidBodies[0].transform[5]} {RigidBodies[0].transform[6]} {RigidBodies[0].transform[7]}");        
    print(f"{RigidBodies[0].transform[8]} {RigidBodies[0].transform[9]} {RigidBodies[0].transform[10]} {RigidBodies[0].transform[11]}");        
    print("");
}

inline void print_camera_prop() {
    print(f"({Properties[0].pos[0]}, {Properties[0].pos[1]}, {Properties[0].pos[2]}) {Properties[0].yaw} {Properties[0].pitch}");
}

void main() {
    // hide cursor
    cmd [121](9000074,0,0,0)();
    const int MOVE_SPEED = 300;
    const int SENS = 1500;

    render_init_cube(1000);
    rb_init_cube(0, 1000, 1000);
    rb_calculate_derived(0);
    RigidBodies[0].position[2] = 500;
    RigidBodies[0].acceleration[1] = 0;

    Properties[0].pos[2] = -5000;
    
    Properties[0].yaw = 900;
    loop {
        // set mouse to point to screen center
        cmd [121](9000071,SCREEN_CENTER_X,0,0)();
        cmd [121](9000072,SCREEN_CENTER_Y,0,0)();

        // get mouse movement since last frame
        int mouse_x_mov;
        int mouse_y_mov;
        cmd [124](mouse_x_mov,12288,11)();
        cmd [124](mouse_y_mov,12288,12)();

        
        Properties[0].yaw -= mouse_x_mov * SENS / 1000;
        Properties[0].pitch -= mouse_y_mov * SENS / 1000;

        if (Properties[0].pitch > 890) Properties[0].pitch = 890;
        if (Properties[0].pitch < -890) Properties[0].pitch = -890;

        int[3] forward;
        forward[0] = cos(Properties[0].yaw) * cos(Properties[0].pitch) / 1000;
        forward[1] = sin(Properties[0].pitch);
        forward[2] = sin(Properties[0].yaw) * cos(Properties[0].pitch) / 1000;
        vec3_normalize(forward);

        int[3] right;
        {
            int[3] t_up;
            t_up[0] = 0;
            t_up[1] = 1000;
            t_up[2] = 0;
            vec3_cross(right, t_up, forward);
            vec3_normalize(right);
        }

        int[3] up;
        // vec3_cross(up, right, forward);
        vec3_cross(up, forward, right);

        Properties[0].look_at[0] = right[0];
        Properties[0].look_at[1] = right[1];
        Properties[0].look_at[2] = right[2];
        Properties[0].look_at[3] = -vec3_dot(right, Properties[0].pos);
        Properties[0].look_at[4] = up[0];
        Properties[0].look_at[5] = up[1];
        Properties[0].look_at[6] = up[2];
        Properties[0].look_at[7] = -vec3_dot(up, Properties[0].pos);
        Properties[0].look_at[8] = forward[0];
        Properties[0].look_at[9] = forward[1];
        Properties[0].look_at[10] = forward[2];
        Properties[0].look_at[11] = -vec3_dot(forward, Properties[0].pos);

        print_camera_prop();

        rb_clear_accum(0);
        if (key(125)) {
            int[3] force;
            force[0] = 0;
            force[1] = 1000;
            force[2] = 0;
            rb_add_force(0, force);
        }
        if (key(124)) {
            int[3] torque;
            torque[0] = 1000;
            torque[1] = 0;
            torque[2] = 0;
            rb_add_torque(0, torque);
        }
        if (key(123)) {
            int[3] force;
            force[0] = 1000;
            force[1] = 2000;
            force[2] = 1234;
            int[3] point;
            point[0] = 50;
            point[1] = 50;
            point[2] = 0;
            rb_add_force_at_pt(0, force, point);
        }

        rb_integrate(0, 16);
        
        render_buffer_cube(RigidBodies[0].transform);
        render_draw();

        if (key(117)) { // W
            vec3_add_scaled(Properties[0].pos, forward, MOVE_SPEED);
        }
        if (key(131)){ // S
            vec3_add_scaled(Properties[0].pos, forward, -MOVE_SPEED);
        }
        if (key(130)) { // A
            vec3_add_scaled(Properties[0].pos, right, -MOVE_SPEED);
        }
        if (key(132)) { // D
            vec3_add_scaled(Properties[0].pos, right, MOVE_SPEED);
        }

        int[3] world_up;
        world_up[0] = 0;
        world_up[1] = 1000;
        world_up[2] = 0;
        if (key(116)) { // Q
            vec3_add_scaled(Properties[0].pos, world_up, -MOVE_SPEED);
        }
        if (key(118)) { // E
            vec3_add_scaled(Properties[0].pos, world_up, MOVE_SPEED);
        }
        wait(1);
    }
}

inline void start_frame(int n_rb) {
    for (int i = 0; i < n_rb; i += 1) {
        rb_clear_accum(i);
        rb_calculate_derived(i);
    }
}

inline void run_physics(int n_rb) {
    for (int i = 0; i < n_rb; i += 1) {
        rb_integrate(i, 16);
    }
}